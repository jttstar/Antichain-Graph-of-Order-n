import itertools
import networkx as nx
import matplotlib.pyplot as plt
import os
import numpy as np

def subsets_of_n(n):
    """Genera todos los subconjuntos de {0,...,n-1} como tuplas ordenadas."""
    for r in range(n+1):
        for combi in itertools.combinations(range(n), r):
            yield tuple(combi)

def is_non_inclusive(a, b):
    """True si ni a ⊆ b ni b ⊆ a."""
    sa, sb = set(a), set(b)
    return not (sa.issubset(sb) or sb.issubset(sa))

def build_noninclusion_graph(n):
    """Construye el grafo de no-inclusión G_X."""
    nodes = list(subsets_of_n(n))
    G = nx.Graph()
    G.add_nodes_from(nodes)
    for i, a in enumerate(nodes):
        for b in nodes[i+1:]:
            if is_non_inclusive(a, b):
                G.add_edge(a, b)
    return G

def layered_positions_ordered(G, n):
    """Posiciones por nivel con orden lexicográfico."""
    levels = {k: [] for k in range(n+1)}
    for node in G.nodes():
        levels[len(node)].append(node)
    for k in levels:
        levels[k] = sorted(levels[k])
    pos = {}
    y_gap = 2
    for k in range(n+1):
        nodes_in_level = levels[k]
        total_width = len(nodes_in_level) - 1
        for i, node in enumerate(nodes_in_level):
            x = i - total_width / 2
            y = -k * y_gap
            pos[node] = (x, y)
    return pos

def generate_colors(n_levels):
    """Genera colores distintos, ampliando si hace falta."""
    base_cmap = plt.cm.get_cmap("tab20", min(n_levels, 20))
    colors = [base_cmap(i) for i in range(min(n_levels, 20))]
    if n_levels > 20:
        extra_needed = n_levels - 20
        hsv_colors = plt.cm.hsv(np.linspace(0, 1, extra_needed + 1))[:-1]
        colors.extend(hsv_colors)
    return colors

def draw_and_save_graph(G, n, pos, title, fname_prefix, output_dir="graficos_no_inclusion"):
    """Dibuja y guarda un grafo con layout fijo."""
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    color_palette = generate_colors(n+1)
    colors = [color_palette[len(node)] for node in G.nodes()]
    labels = {node: "{" + ",".join(map(str, node)) + "}" if node else "∅"
              for node in G.nodes()}

    plt.figure(figsize=(8, 1.8*(n+1)))
    nx.draw_networkx_nodes(G, pos, node_color=colors, node_size=600, edgecolors="black")
    nx.draw_networkx_edges(G, pos, alpha=0.6, width=1)
    nx.draw_networkx_labels(G, pos, labels=labels, font_size=8)
    plt.axis('off')
    plt.title(title)
    plt.tight_layout()

    png_path = os.path.join(output_dir, f"{fname_prefix}_n{n}.png")
    svg_path = os.path.join(output_dir, f"{fname_prefix}_n{n}.svg")
    plt.savefig(png_path, dpi=300, bbox_inches="tight")
    plt.savefig(svg_path, format="svg", bbox_inches="tight")
    print(f"Guardado: {png_path}")
    print(f"Guardado: {svg_path}")
    plt.close()

if __name__ == "__main__":
    valores_n = [3, 4, 5, 6]  # cámbialos según lo que necesites

    for n in valores_n:
        # Grafo de no-inclusión
        G = build_noninclusion_graph(n)
        pos = layered_positions_ordered(G, n)

        # Complemento (inclusión)
        G_comp = nx.complement(G)

        # Dibujar y guardar ambos
        draw_and_save_graph(G, n, pos,
                            title=f"Grafo de no-inclusión G_X (n={n})",
                            fname_prefix="GX_no_inclusion")
        draw_and_save_graph(G_comp, n, pos,
                            title=f"Complemento de G_X (n={n})",
                            fname_prefix="GX_complemento")
